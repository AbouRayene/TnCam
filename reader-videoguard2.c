#include "globals.h"
#include "reader-common.h"

#include <termios.h>
#include <unistd.h>
#ifdef OS_LINUX
#include <linux/serial.h>
#endif

#define MAX_ATR_LEN 33         // max. ATR length
#define MAX_HIST    15         // max. number of historical characters

//////  ====================================================================================

int aes_active=0;
AES_KEY dkey, ekey;
int BASEYEAR = 1997;
static void cAES_SetKey(const unsigned char *key)
{
  AES_set_decrypt_key(key,128,&dkey);
  AES_set_encrypt_key(key,128,&ekey);
  aes_active=1;
}

static int cAES_Encrypt(const unsigned char *data, int len, unsigned char *crypt)
{
  if(aes_active) {
    len=(len+15)&(~15); // pad up to a multiple of 16
    int i;
    for(i=0; i<len; i+=16) AES_encrypt(data+i,crypt+i,(const AES_KEY *)&ekey);
    return len;
    }
  return -1;
}

static int cw_is_valid(unsigned char *cw) //returns 1 if cw_is_valid, returns 0 if cw is all zeros
{
  int i;
  for (i = 0; i < 8; i++)
    if (cw[i] != 0) {//test if cw = 00
      return OK;
    }
  return ERROR;
}

//////  ====================================================================================
//////  special thanks to an "italian forum" !!!!


static void postprocess_cw(unsigned char *cw, int nTableIdx)
{

  if (!cw_is_valid(cw)) //if cw is all zero, keep it that way
    return;
#if __BYTE_ORDER == __BIG_ENDIAN
  static unsigned char Tb1[0xC]={0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0xF8,0x61,0xCB,0x52};
  static unsigned char Tb2[0x540]= {
		0xEA,0xF1,0x02,0x37,0x29,0xD0,0xBA,0xD2,0xE9,0xD3,0x8B,0xAE,0x2D,0x6D,0xCD,0x1B,0x53,0x8D,0xDE,0x6B,0xA6,0x34,0xF8,0x1A,0x18,0xB5,0x50,0x87,0x14,0xEA,0x67,0x2E,
		0xF0,0xFC,0x05,0x5E,0x62,0xE5,0xB7,0x8F,0x5D,0x09,0x00,0x03,0xE4,0xE8,0x2D,0xCE,0x6B,0xE0,0xAC,0x4E,0xF4,0x85,0x69,0x67,0xF2,0x8C,0x97,0xA0,0x01,0xEF,0x01,0x00,
		0xC5,0x39,0xF5,0xB9,0x90,0x99,0x01,0x3A,0xD4,0xB9,0x6A,0xB5,0xEA,0x67,0x7E,0xB4,0x6C,0x30,0x4B,0xF0,0xB8,0x10,0xB0,0xB5,0xB7,0x6D,0xA7,0x51,0x1A,0xE7,0x14,0xCA,
		0x4F,0x4F,0x15,0x86,0x26,0x08,0x10,0xB1,0xE7,0xE1,0x48,0xBE,0x7D,0xDD,0x5E,0xCB,0xCF,0xBF,0x32,0x3B,0x8B,0x31,0xB1,0x31,0x0F,0x1A,0x66,0x4B,0x01,0x40,0x01,0x00,
		0x3C,0x7D,0xBD,0xC4,0xFE,0xC7,0x26,0xA6,0xB0,0xA0,0x6E,0x55,0xF7,0x10,0xF9,0xBF,0x00,0x23,0xE8,0x1F,0x41,0xCA,0xBE,0x32,0xB4,0x61,0xE9,0x2D,0xF1,0xAF,0x40,0x9F,
		0xFC,0x85,0xFE,0x5B,0x7F,0xCE,0x17,0xF5,0x01,0xAB,0x4A,0x46,0xEB,0x05,0xA2,0x51,0xDC,0x6F,0xF0,0xC0,0x10,0xF0,0x1D,0x51,0xEF,0xAA,0xE9,0xBF,0x01,0x00,0x01,0x00,
		0x18,0x19,0x0C,0xAA,0x90,0x67,0x60,0x7A,0x75,0x76,0x1C,0xBC,0xE5,0x1D,0xBF,0x77,0x7E,0xC6,0x83,0x9E,0xB6,0x95,0xF0,0x96,0xDC,0x10,0xCB,0x69,0x46,0x54,0x8E,0x68,
		0xD6,0x2D,0x4F,0x1A,0x42,0x27,0x92,0xAC,0x90,0x64,0x6B,0xD1,0x1E,0x75,0x27,0x47,0x00,0xDA,0xA6,0xA6,0x6C,0xF1,0xD1,0x51,0xBE,0x56,0x3E,0x33,0x01,0x28,0x01,0x00,
		0x40,0x91,0x09,0xED,0xD4,0x94,0x60,0x54,0x18,0x69,0x71,0xD5,0xB5,0x72,0x7B,0xF1,0xE9,0x25,0xEE,0x2D,0xEE,0xDE,0xA1,0x3C,0x66,0x13,0x9B,0xAB,0x12,0x2D,0x7A,0xE4,
		0x52,0x68,0xE6,0xC9,0x50,0xCB,0x79,0xA1,0xF2,0x12,0xA0,0x62,0x6B,0x48,0x70,0xB3,0xF6,0xB0,0x06,0xD5,0xF8,0xAB,0xEC,0xF5,0x62,0x55,0xED,0xD8,0x79,0xD2,0x29,0x0A,
		0xD3,0xCF,0x01,0x4E,0xAC,0xB3,0x8F,0x6B,0x0F,0x2C,0xA5,0xD8,0xE8,0xE0,0x86,0x3D,0x80,0xD5,0x57,0x05,0x65,0x8A,0x8B,0xC2,0xEE,0x46,0xD3,0xAE,0x01,0x99,0x01,0x00,
		0x4A,0x35,0xAB,0xE4,0xF9,0x76,0x93,0x5A,0xA8,0xA5,0xBA,0xE9,0x24,0xD0,0x71,0xAA,0xB3,0xFE,0x09,0x5E,0xAB,0x06,0x4C,0xD5,0x2F,0x0D,0x1A,0xCB,0x59,0xF3,0x4C,0x50,
		0xFD,0x27,0x0F,0x8E,0x19,0x1A,0xEE,0xE7,0x2F,0x49,0x3A,0x05,0x32,0x67,0x4F,0x88,0x38,0xAE,0xFC,0xE9,0x94,0x76,0x18,0xC6,0xF9,0x61,0x4E,0xF0,0x39,0xD0,0x42,0xE6,
		0xB7,0x47,0xE6,0x25,0xB6,0x8E,0x51,0x00,0xF9,0x2A,0x86,0xFE,0xE7,0x9B,0xEE,0x91,0x21,0xD5,0x4C,0x3C,0x68,0x3D,0x5A,0xD1,0x1B,0x49,0xF4,0x07,0x01,0x94,0x01,0x00,
		0x4B,0xF9,0xDC,0x0D,0x94,0x78,0x51,0x74,0xCB,0x4A,0x8A,0x89,0x4D,0x6A,0xFE,0xD8,0xF1,0x23,0xA8,0xCD,0xEE,0xE7,0xA6,0xD1,0xB7,0x63,0xF5,0xE2,0xE0,0x85,0x01,0xEF,
		0xE4,0x66,0x9F,0xA3,0x2F,0x68,0x21,0x90,0x42,0x3F,0x28,0x7F,0x7F,0x3F,0x09,0xF6,0x21,0x11,0xA9,0x63,0xD0,0xBB,0x67,0x4A,0xBA,0x72,0x45,0xF9,0xF1,0x86,0xB8,0xF5,
		0x00,0x10,0xD1,0xB9,0xB1,0x64,0x9E,0x87,0x1F,0x49,0x69,0x50,0x2D,0xBF,0x38,0xD3,0x2E,0xB0,0x3E,0x8E,0x91,0xE6,0xF6,0x88,0x7E,0x41,0x56,0x6E,0x01,0xB0,0x01,0x00,
		0x24,0xA1,0x73,0xD8,0xA0,0xC3,0xF7,0x1B,0xA0,0xA5,0x2A,0x06,0xBA,0x46,0xFE,0xC3,0xDD,0x4C,0x52,0xCC,0xF9,0xBC,0x3B,0x7E,0x38,0x12,0x06,0x66,0xB7,0x4B,0x40,0xF8,
		0x28,0xF2,0x7C,0x81,0xFC,0x92,0x6F,0xBD,0x53,0xD6,0x72,0xA3,0xBB,0xDF,0xB6,0xFC,0x9C,0xE5,0x23,0x31,0xD4,0xF6,0xC5,0xBB,0xE8,0xBB,0x66,0x76,0x02,0xD9,0x2F,0x0E,
		0xD0,0x09,0xD1,0x36,0xCD,0x09,0x75,0x51,0x18,0x26,0x9D,0x9B,0x63,0xEA,0xFC,0x63,0x68,0xCD,0x36,0x72,0xCB,0x95,0xD2,0x8E,0xF1,0xCD,0x20,0xCA,0x01,0x4C,0x01,0x00,
		0xE5,0x39,0x55,0xB7,0x98,0x9D,0x21,0xC4,0x46,0x3A,0xE6,0x8F,0xF8,0xB5,0xE5,0xC5,0x66,0x2B,0x35,0xBF,0x3C,0x50,0x01,0x31,0xF4,0xBF,0x38,0xB2,0x41,0xBC,0xB8,0x29,
		0x02,0xB7,0x6B,0x8F,0xA2,0x5C,0xAF,0xD2,0xD8,0x4A,0x22,0x43,0x53,0xEB,0xC6,0xC9,0x2E,0x14,0x18,0x1F,0x8F,0x96,0xDF,0x0E,0x0D,0x4C,0x30,0xF6,0xFF,0xE1,0x9D,0xDA,
		0x30,0xB6,0x77,0x7E,0xDA,0x3D,0xAF,0x77,0x20,0x5E,0xC9,0x0B,0x85,0x6B,0xB4,0x51,0x3B,0xCC,0x76,0xC2,0x8A,0xCF,0xDC,0xB1,0xA5,0xE5,0xDD,0x64,0x01,0x97,0x01,0x00,
		0xE7,0x51,0xB6,0x61,0x04,0x04,0xDB,0x4A,0xE9,0xDD,0xA4,0x00,0xAF,0x26,0x3F,0x5E,0x90,0x4B,0xA9,0x24,0x09,0xE0,0xE7,0x2B,0x82,0x5B,0x2C,0x50,0x6F,0xD0,0x0D,0x52,
		0x27,0x30,0xC2,0xBA,0x9E,0x44,0x58,0x15,0xFC,0x47,0xB2,0x1D,0x67,0xB8,0xF8,0xB9,0x04,0x7D,0xB0,0xAF,0x9F,0x14,0x74,0x1B,0x46,0x68,0xBE,0x54,0xDE,0x16,0xDB,0x14,
		0x7C,0xB7,0xF2,0xB8,0x06,0x83,0x76,0x2C,0x09,0xA0,0x95,0x07,0x7F,0x92,0x02,0x2C,0xBA,0x6A,0x7D,0x52,0x0A,0xF4,0x1B,0xC3,0xB4,0x6A,0xC4,0xFD,0x01,0xC2,0x01,0x00,
		0x76,0x11,0x66,0xF3,0xEE,0x87,0xED,0xD3,0xC5,0x59,0xEF,0xD4,0xDC,0x59,0xF8,0x6B,0x6D,0x1C,0x1C,0x85,0x9B,0xB1,0x33,0x73,0x76,0x3F,0x4E,0xBE,0x1B,0xF3,0x99,0xB5,
		0xD7,0x21,0x97,0x8F,0xCF,0x5C,0xAC,0x51,0x09,0x84,0x74,0x62,0x8F,0x0C,0x28,0x17,0x4A,0xD9,0xFD,0x41,0x66,0x78,0x7C,0x85,0xD3,0x30,0xC9,0xF8,0x1D,0x9A,0xC6,0x22,
		0x5A,0xE4,0xE1,0x6A,0x60,0xF6,0xFD,0x45,0x66,0x8C,0x29,0xD6,0x02,0x85,0x6B,0x92,0x92,0xC2,0x21,0xDE,0x45,0xE0,0xEF,0x3D,0x8B,0x0D,0x02,0xCD,0x01,0x98,0x01,0x00,
		0x9E,0x6D,0x4D,0x38,0xDE,0xF9,0xE6,0xF2,0xF7,0x2E,0xB3,0x13,0x14,0xF2,0x39,0x0A,0x2D,0x67,0xC7,0x1E,0xCB,0x69,0x7F,0x66,0xD3,0xCF,0x7F,0x8A,0x81,0xD9,0x9D,0xDE,
		0x85,0xE3,0x8F,0x29,0x36,0xEB,0xC9,0x68,0x36,0x96,0x59,0xF6,0x78,0x32,0xA7,0x8B,0xA1,0xD8,0xF5,0xCF,0xAB,0x64,0x64,0x6D,0x7A,0x2A,0xBA,0xF8,0xAA,0x87,0x41,0xC7,
		0x51,0x20,0xDE,0x78,0x73,0x8D,0xDC,0x1A,0x26,0x8D,0x5D,0xF8,0xED,0x69,0x1C,0x8A,0xBC,0x85,0x3D,0xCD,0xAE,0x30,0x0F,0x8D,0xEC,0x89,0x3A,0xBD,0x01,0x66,0x01,0x00,
		0xB8,0xBD,0x64,0x3B,0x74,0x8E,0xBD,0x63,0xEC,0x6F,0xE2,0x3A,0x94,0x93,0xDD,0x76,0x0A,0x62,0x77,0x4F,0xCD,0x68,0xA6,0x7A,0x9A,0x23,0xC8,0xA8,0xBD,0xE5,0x9D,0x1B,
		0x2B,0x86,0x8B,0x36,0x54,0x28,0x1D,0xFB,0xCD,0x1D,0x07,0x13,0x29,0xC2,0x8E,0x8E,0x52,0x07,0xA1,0x3F,0x60,0x05,0x4F,0x5E,0x52,0xE0,0xE7,0xC8,0x6D,0x1C,0x3E,0x34,
		0x58,0x1D,0x2B,0xFA,0x5E,0x1D,0xA8,0x91,0x10,0x69,0x1D,0xA4,0x39,0xA0,0xBE,0x45,0x5B,0x9A,0x73,0x33,0x6F,0x3E,0x86,0x37,0xA5,0x50,0xC9,0xE9,0x5C,0x6C,0x42,0xBA,
		0xA7,0x12,0xC3,0xEA,0x38,0x08,0x09,0x10,0xAA,0x4D,0x5B,0x25,0xAB,0xCD,0xE6,0x80,0x96,0xAD,0x2C,0xEC,0x8E,0xBB,0xA4,0x7D,0x16,0x90,0xE8,0xFB,0x01,0xC8,0x01,0x00,
		0x73,0xB9,0x82,0xBC,0x9E,0xBC,0xB1,0x30,0x0D,0xA5,0x86,0x17,0x9F,0x7B,0x97,0x66,0x20,0x5D,0x75,0x2D,0xB0,0x5C,0x2A,0x17,0xA7,0x5C,0x18,0xEF,0x83,0x39,0xFD,0x34,
		0x8D,0xA2,0x79,0x70,0xD0,0xB4,0x70,0xF1,0x37,0x65,0x73,0x80,0x7C,0xAF,0x57,0x0E,0x64,0x40,0xBC,0x44,0x07,0x43,0x2D,0x02,0x04,0x19,0xA2,0x40,0x21,0x13,0x1A,0xD4,
		0x1E,0xB5,0xBB,0xFF,0x39,0xB1,0x32,0x09,0x70,0x5F,0x15,0xF4,0xD7,0xAD,0x34,0x0B,0xC2,0xA6,0x25,0xCA,0xF4,0x12,0x95,0x70,0x0F,0x4F,0xE4,0xD5,0x16,0x14,0xE4,0x64,
		0x91,0x1A,0x0F,0x0E,0x07,0xDA,0xA9,0x29,0x23,0x79,0xD9,0x88,0x0A,0xA6,0x3B,0x57,0xBF,0x63,0x71,0xFB,0x72,0xD5,0x26,0xCE,0xB0,0xAF,0xCF,0x45,0x01,0x1B,0x01,0x00,
		0x99,0x99,0x98,0xFE,0xA1,0x08,0x65,0x88,0xF9,0x0B,0x45,0x54,0xFF,0x38,0x46,0x42,0x8F,0x5F,0x6C,0xC3,0x4E,0x8E,0xFF,0x7E,0x64,0xC2,0x50,0xCA,0x0E,0x7F,0xAD,0x7D,
		0x6A,0xAB,0x33,0xC1,0xE1,0xF4,0x61,0x65,0x78,0x94,0x83,0xB9,0x0A,0x0C,0x38,0xAF,0x58,0x03,0x18,0xC0,0xFA,0x36,0x59,0x2C,0x45,0x48,0xAB,0xB8,0x15,0x27,0xAE,0xE9,
  };
#else
  static unsigned char Tb1[0xC]={0x23,0x01,0x67,0x45,0xAB,0x89,0xEF,0xCD,0x61,0xF8,0x52,0xCB};
  static unsigned char Tb2[0x540]= {
		0xF1,0xEA,0x37,0x02,0xD0,0x29,0xD2,0xBA,0xD3,0xE9,0xAE,0x8B,0x6D,0x2D,0x1B,0xCD,0x8D,0x53,0x6B,0xDE,0x34,0xA6,0x1A,0xF8,0xB5,0x18,0x87,0x50,0xEA,0x14,0x2E,0x67,
		0xFC,0xF0,0x5E,0x05,0xE5,0x62,0x8F,0xB7,0x09,0x5D,0x03,0x00,0xE8,0xE4,0xCE,0x2D,0xE0,0x6B,0x4E,0xAC,0x85,0xF4,0x67,0x69,0x8C,0xF2,0xA0,0x97,0xEF,0x01,0x00,0x01,
		0x39,0xC5,0xB9,0xF5,0x99,0x90,0x3A,0x01,0xB9,0xD4,0xB5,0x6A,0x67,0xEA,0xB4,0x7E,0x30,0x6C,0xF0,0x4B,0x10,0xB8,0xB5,0xB0,0x6D,0xB7,0x51,0xA7,0xE7,0x1A,0xCA,0x14,
		0x4F,0x4F,0x86,0x15,0x08,0x26,0xB1,0x10,0xE1,0xE7,0xBE,0x48,0xDD,0x7D,0xCB,0x5E,0xBF,0xCF,0x3B,0x32,0x31,0x8B,0x31,0xB1,0x1A,0x0F,0x4B,0x66,0x40,0x01,0x00,0x01,
		0x7D,0x3C,0xC4,0xBD,0xC7,0xFE,0xA6,0x26,0xA0,0xB0,0x55,0x6E,0x10,0xF7,0xBF,0xF9,0x23,0x00,0x1F,0xE8,0xCA,0x41,0x32,0xBE,0x61,0xB4,0x2D,0xE9,0xAF,0xF1,0x9F,0x40,
		0x85,0xFC,0x5B,0xFE,0xCE,0x7F,0xF5,0x17,0xAB,0x01,0x46,0x4A,0x05,0xEB,0x51,0xA2,0x6F,0xDC,0xC0,0xF0,0xF0,0x10,0x51,0x1D,0xAA,0xEF,0xBF,0xE9,0x00,0x01,0x00,0x01,
		0x19,0x18,0xAA,0x0C,0x67,0x90,0x7A,0x60,0x76,0x75,0xBC,0x1C,0x1D,0xE5,0x77,0xBF,0xC6,0x7E,0x9E,0x83,0x95,0xB6,0x96,0xF0,0x10,0xDC,0x69,0xCB,0x54,0x46,0x68,0x8E,
		0x2D,0xD6,0x1A,0x4F,0x27,0x42,0xAC,0x92,0x64,0x90,0xD1,0x6B,0x75,0x1E,0x47,0x27,0xDA,0x00,0xA6,0xA6,0xF1,0x6C,0x51,0xD1,0x56,0xBE,0x33,0x3E,0x28,0x01,0x00,0x01,
		0x91,0x40,0xED,0x09,0x94,0xD4,0x54,0x60,0x69,0x18,0xD5,0x71,0x72,0xB5,0xF1,0x7B,0x25,0xE9,0x2D,0xEE,0xDE,0xEE,0x3C,0xA1,0x13,0x66,0xAB,0x9B,0x2D,0x12,0xE4,0x7A,
		0x68,0x52,0xC9,0xE6,0xCB,0x50,0xA1,0x79,0x12,0xF2,0x62,0xA0,0x48,0x6B,0xB3,0x70,0xB0,0xF6,0xD5,0x06,0xAB,0xF8,0xF5,0xEC,0x55,0x62,0xD8,0xED,0xD2,0x79,0x0A,0x29,
		0xCF,0xD3,0x4E,0x01,0xB3,0xAC,0x6B,0x8F,0x2C,0x0F,0xD8,0xA5,0xE0,0xE8,0x3D,0x86,0xD5,0x80,0x05,0x57,0x8A,0x65,0xC2,0x8B,0x46,0xEE,0xAE,0xD3,0x99,0x01,0x00,0x01,
		0x35,0x4A,0xE4,0xAB,0x76,0xF9,0x5A,0x93,0xA5,0xA8,0xE9,0xBA,0xD0,0x24,0xAA,0x71,0xFE,0xB3,0x5E,0x09,0x06,0xAB,0xD5,0x4C,0x0D,0x2F,0xCB,0x1A,0xF3,0x59,0x50,0x4C,
		0x27,0xFD,0x8E,0x0F,0x1A,0x19,0xE7,0xEE,0x49,0x2F,0x05,0x3A,0x67,0x32,0x88,0x4F,0xAE,0x38,0xE9,0xFC,0x76,0x94,0xC6,0x18,0x61,0xF9,0xF0,0x4E,0xD0,0x39,0xE6,0x42,
		0x47,0xB7,0x25,0xE6,0x8E,0xB6,0x00,0x51,0x2A,0xF9,0xFE,0x86,0x9B,0xE7,0x91,0xEE,0xD5,0x21,0x3C,0x4C,0x3D,0x68,0xD1,0x5A,0x49,0x1B,0x07,0xF4,0x94,0x01,0x00,0x01,
		0xF9,0x4B,0x0D,0xDC,0x78,0x94,0x74,0x51,0x4A,0xCB,0x89,0x8A,0x6A,0x4D,0xD8,0xFE,0x23,0xF1,0xCD,0xA8,0xE7,0xEE,0xD1,0xA6,0x63,0xB7,0xE2,0xF5,0x85,0xE0,0xEF,0x01,
		0x66,0xE4,0xA3,0x9F,0x68,0x2F,0x90,0x21,0x3F,0x42,0x7F,0x28,0x3F,0x7F,0xF6,0x09,0x11,0x21,0x63,0xA9,0xBB,0xD0,0x4A,0x67,0x72,0xBA,0xF9,0x45,0x86,0xF1,0xF5,0xB8,
		0x10,0x00,0xB9,0xD1,0x64,0xB1,0x87,0x9E,0x49,0x1F,0x50,0x69,0xBF,0x2D,0xD3,0x38,0xB0,0x2E,0x8E,0x3E,0xE6,0x91,0x88,0xF6,0x41,0x7E,0x6E,0x56,0xB0,0x01,0x00,0x01,
		0xA1,0x24,0xD8,0x73,0xC3,0xA0,0x1B,0xF7,0xA5,0xA0,0x06,0x2A,0x46,0xBA,0xC3,0xFE,0x4C,0xDD,0xCC,0x52,0xBC,0xF9,0x7E,0x3B,0x12,0x38,0x66,0x06,0x4B,0xB7,0xF8,0x40,
		0xF2,0x28,0x81,0x7C,0x92,0xFC,0xBD,0x6F,0xD6,0x53,0xA3,0x72,0xDF,0xBB,0xFC,0xB6,0xE5,0x9C,0x31,0x23,0xF6,0xD4,0xBB,0xC5,0xBB,0xE8,0x76,0x66,0xD9,0x02,0x0E,0x2F,
		0x09,0xD0,0x36,0xD1,0x09,0xCD,0x51,0x75,0x26,0x18,0x9B,0x9D,0xEA,0x63,0x63,0xFC,0xCD,0x68,0x72,0x36,0x95,0xCB,0x8E,0xD2,0xCD,0xF1,0xCA,0x20,0x4C,0x01,0x00,0x01,
		0x39,0xE5,0xB7,0x55,0x9D,0x98,0xC4,0x21,0x3A,0x46,0x8F,0xE6,0xB5,0xF8,0xC5,0xE5,0x2B,0x66,0xBF,0x35,0x50,0x3C,0x31,0x01,0xBF,0xF4,0xB2,0x38,0xBC,0x41,0x29,0xB8,
		0xB7,0x02,0x8F,0x6B,0x5C,0xA2,0xD2,0xAF,0x4A,0xD8,0x43,0x22,0xEB,0x53,0xC9,0xC6,0x14,0x2E,0x1F,0x18,0x96,0x8F,0x0E,0xDF,0x4C,0x0D,0xF6,0x30,0xE1,0xFF,0xDA,0x9D,
		0xB6,0x30,0x7E,0x77,0x3D,0xDA,0x77,0xAF,0x5E,0x20,0x0B,0xC9,0x6B,0x85,0x51,0xB4,0xCC,0x3B,0xC2,0x76,0xCF,0x8A,0xB1,0xDC,0xE5,0xA5,0x64,0xDD,0x97,0x01,0x00,0x01,
		0x51,0xE7,0x61,0xB6,0x04,0x04,0x4A,0xDB,0xDD,0xE9,0x00,0xA4,0x26,0xAF,0x5E,0x3F,0x4B,0x90,0x24,0xA9,0xE0,0x09,0x2B,0xE7,0x5B,0x82,0x50,0x2C,0xD0,0x6F,0x52,0x0D,
		0x30,0x27,0xBA,0xC2,0x44,0x9E,0x15,0x58,0x47,0xFC,0x1D,0xB2,0xB8,0x67,0xB9,0xF8,0x7D,0x04,0xAF,0xB0,0x14,0x9F,0x1B,0x74,0x68,0x46,0x54,0xBE,0x16,0xDE,0x14,0xDB,
		0xB7,0x7C,0xB8,0xF2,0x83,0x06,0x2C,0x76,0xA0,0x09,0x07,0x95,0x92,0x7F,0x2C,0x02,0x6A,0xBA,0x52,0x7D,0xF4,0x0A,0xC3,0x1B,0x6A,0xB4,0xFD,0xC4,0xC2,0x01,0x00,0x01,
		0x11,0x76,0xF3,0x66,0x87,0xEE,0xD3,0xED,0x59,0xC5,0xD4,0xEF,0x59,0xDC,0x6B,0xF8,0x1C,0x6D,0x85,0x1C,0xB1,0x9B,0x73,0x33,0x3F,0x76,0xBE,0x4E,0xF3,0x1B,0xB5,0x99,
		0x21,0xD7,0x8F,0x97,0x5C,0xCF,0x51,0xAC,0x84,0x09,0x62,0x74,0x0C,0x8F,0x17,0x28,0xD9,0x4A,0x41,0xFD,0x78,0x66,0x85,0x7C,0x30,0xD3,0xF8,0xC9,0x9A,0x1D,0x22,0xC6,
		0xE4,0x5A,0x6A,0xE1,0xF6,0x60,0x45,0xFD,0x8C,0x66,0xD6,0x29,0x85,0x02,0x92,0x6B,0xC2,0x92,0xDE,0x21,0xE0,0x45,0x3D,0xEF,0x0D,0x8B,0xCD,0x02,0x98,0x01,0x00,0x01,
		0x6D,0x9E,0x38,0x4D,0xF9,0xDE,0xF2,0xE6,0x2E,0xF7,0x13,0xB3,0xF2,0x14,0x0A,0x39,0x67,0x2D,0x1E,0xC7,0x69,0xCB,0x66,0x7F,0xCF,0xD3,0x8A,0x7F,0xD9,0x81,0xDE,0x9D,
		0xE3,0x85,0x29,0x8F,0xEB,0x36,0x68,0xC9,0x96,0x36,0xF6,0x59,0x32,0x78,0x8B,0xA7,0xD8,0xA1,0xCF,0xF5,0x64,0xAB,0x6D,0x64,0x2A,0x7A,0xF8,0xBA,0x87,0xAA,0xC7,0x41,
		0x20,0x51,0x78,0xDE,0x8D,0x73,0x1A,0xDC,0x8D,0x26,0xF8,0x5D,0x69,0xED,0x8A,0x1C,0x85,0xBC,0xCD,0x3D,0x30,0xAE,0x8D,0x0F,0x89,0xEC,0xBD,0x3A,0x66,0x01,0x00,0x01,
		0xBD,0xB8,0x3B,0x64,0x8E,0x74,0x63,0xBD,0x6F,0xEC,0x3A,0xE2,0x93,0x94,0x76,0xDD,0x62,0x0A,0x4F,0x77,0x68,0xCD,0x7A,0xA6,0x23,0x9A,0xA8,0xC8,0xE5,0xBD,0x1B,0x9D,
		0x86,0x2B,0x36,0x8B,0x28,0x54,0xFB,0x1D,0x1D,0xCD,0x13,0x07,0xC2,0x29,0x8E,0x8E,0x07,0x52,0x3F,0xA1,0x05,0x60,0x5E,0x4F,0xE0,0x52,0xC8,0xE7,0x1C,0x6D,0x34,0x3E,
		0x1D,0x58,0xFA,0x2B,0x1D,0x5E,0x91,0xA8,0x69,0x10,0xA4,0x1D,0xA0,0x39,0x45,0xBE,0x9A,0x5B,0x33,0x73,0x3E,0x6F,0x37,0x86,0x50,0xA5,0xE9,0xC9,0x6C,0x5C,0xBA,0x42,
		0x12,0xA7,0xEA,0xC3,0x08,0x38,0x10,0x09,0x4D,0xAA,0x25,0x5B,0xCD,0xAB,0x80,0xE6,0xAD,0x96,0xEC,0x2C,0xBB,0x8E,0x7D,0xA4,0x90,0x16,0xFB,0xE8,0xC8,0x01,0x00,0x01,
		0xB9,0x73,0xBC,0x82,0xBC,0x9E,0x30,0xB1,0xA5,0x0D,0x17,0x86,0x7B,0x9F,0x66,0x97,0x5D,0x20,0x2D,0x75,0x5C,0xB0,0x17,0x2A,0x5C,0xA7,0xEF,0x18,0x39,0x83,0x34,0xFD,
		0xA2,0x8D,0x70,0x79,0xB4,0xD0,0xF1,0x70,0x65,0x37,0x80,0x73,0xAF,0x7C,0x0E,0x57,0x40,0x64,0x44,0xBC,0x43,0x07,0x02,0x2D,0x19,0x04,0x40,0xA2,0x13,0x21,0xD4,0x1A,
		0xB5,0x1E,0xFF,0xBB,0xB1,0x39,0x09,0x32,0x5F,0x70,0xF4,0x15,0xAD,0xD7,0x0B,0x34,0xA6,0xC2,0xCA,0x25,0x12,0xF4,0x70,0x95,0x4F,0x0F,0xD5,0xE4,0x14,0x16,0x64,0xE4,
		0x1A,0x91,0x0E,0x0F,0xDA,0x07,0x29,0xA9,0x79,0x23,0x88,0xD9,0xA6,0x0A,0x57,0x3B,0x63,0xBF,0xFB,0x71,0xD5,0x72,0xCE,0x26,0xAF,0xB0,0x45,0xCF,0x1B,0x01,0x00,0x01,
		0x99,0x99,0xFE,0x98,0x08,0xA1,0x88,0x65,0x0B,0xF9,0x54,0x45,0x38,0xFF,0x42,0x46,0x5F,0x8F,0xC3,0x6C,0x8E,0x4E,0x7E,0xFF,0xC2,0x64,0xCA,0x50,0x7F,0x0E,0x7D,0xAD,
		0xAB,0x6A,0xC1,0x33,0xF4,0xE1,0x65,0x61,0x94,0x78,0xB9,0x83,0x0C,0x0A,0xAF,0x38,0x03,0x58,0xC0,0x18,0x36,0xFA,0x2C,0x59,0x48,0x45,0xB8,0xAB,0x27,0x15,0xE9,0xAE,

  };
#endif
  unsigned char tabletmp2[0x10] = {0x0B,0x04,0x07,0x08,0x05,0x09,0x0B,0x0A,0x07,0x02,0x0A,0x05,0x04,0x08,0x0D,0x0F};
  unsigned char table40[0x40];
  unsigned char Hash48[0x48];
  unsigned char Hash14[0x14];
  unsigned char counter=0,counter2=0;
  int tmp1;
  int h,j,k,l,m = 0;
  int i;


  memset(Hash48,0,0x48);
  for (i = 0; i < 8; i++)
    Hash48[i] = cw[i];
  Hash48[8]=0x80;


  memcpy(table40,&Tb2[nTableIdx*0x40],0x40);

  for(i = 0; i < 12; i++) Hash14[i] = Tb1[i];

  int k1 = *((short*) &Hash14);  int k2 = *((short*) &Hash14+1);  int k3 = *((short*) &Hash14+2);
  int k4 = *((short*) &Hash14+3);  int k5 = *((short*) &Hash14+4);  int k6 = *((short*) &Hash14+5);
  for (m = 0; m < 2; m++) {
    int loop;
    for (loop = 0; loop < 0x24; loop++) {
      h=((Hash48[(loop<<1) +1]<<8)+Hash48[loop<<1])&0xFFFF;
      if(m)
        tmp1 = (((k2 & k4) | ((~k4) & k3)) & 0xFFFF);
      else
        tmp1 = (((k2 & k3) | ((~k2) & k4)) & 0xFFFF);
      if((counter & 1))
        k = *(((short *) table40)+(counter>>1))>>8;
      else
        k = *(((short *) table40)+(counter>>1));
      l = k1;  j = k2;
      k1 = k2;  k2 = k3;  k3 = k4;  k4 = k5;  k5 = k6;
      k6 = ((tmp1 + l + h + (k & 0xFF)) & 0xFFFF);
      tmp1 = tabletmp2[counter2];
      k6 = ((((k6 << tmp1) | (k6 >> (0x10 - tmp1))) + j) & 0xFFFF);
      counter2++;
      if(counter2 == 0x10) counter2 = 0;
      counter++;
      if(counter == 0x40) counter = 0;
    }
  }

//#if __BYTE_ORDER != __BIG_ENDIAN
  cw[0] = (k1 + *((short *)&Hash14)) & 0xFF;
  cw[1] = (k1 + *((short *)&Hash14))>>8;
  cw[2] = (k2 + *((short *)&Hash14+1)) & 0xFF;
  cw[3] = (cw[0] + cw[1] + cw[2]) & 0xFF;
  cw[4] = (k3 + *((short *)&Hash14+2)) & 0xFF;
  cw[5] = (k3 + *((short *)&Hash14+2))>>8;
  cw[6] = (k4 + *((short *)&Hash14+3)) & 0xFF;
  cw[7] = (cw[4] + cw[5] + cw[6]) & 0xFF;
/*#else
  cw[0] = (k1 + *((short *)&Hash14))>>8;
  cw[1] = (k1 + *((short *)&Hash14)) & 0xFF;
  cw[2] = (k2 + *((short *)&Hash14+1))>>8;
  cw[3] = (cw[0] + cw[1] + cw[2]) & 0xFF;
  cw[4] = (k3 + *((short *)&Hash14+2))>>8;
  cw[5] = (k3 + *((short *)&Hash14+2)) & 0xFF;
  cw[6] = (k4 + *((short *)&Hash14+3))>>8;
  cw[7] = (cw[4] + cw[5] + cw[6]) & 0xFF;
#endif*/

  cs_ddump (cw, 8, "Postprocessed DW:");
}


//////  ====================================================================================

static void swap_lb (unsigned char *buff, int len)
{

#if __BYTE_ORDER != __BIG_ENDIAN
  return;

#endif /*  */
  int i;
  unsigned short *tmp;
  for (i = 0; i < len / 2; i++) {
    tmp = (unsigned short *) buff + i;
    *tmp = ((*tmp << 8) & 0xff00) | ((*tmp >> 8) & 0x00ff);
  }
}

static inline void __xxor(unsigned char *data, int len, const unsigned char *v1, const unsigned char *v2)
{
  switch(len) { // looks ugly, but the compiler can optimize it very well ;)
    case 16:
      *((unsigned int *)data+3) = *((unsigned int *)v1+3) ^ *((unsigned int *)v2+3);
      *((unsigned int *)data+2) = *((unsigned int *)v1+2) ^ *((unsigned int *)v2+2);
    case 8:
      *((unsigned int *)data+1) = *((unsigned int *)v1+1) ^ *((unsigned int *)v2+1);
    case 4:
      *((unsigned int *)data+0) = *((unsigned int *)v1+0) ^ *((unsigned int *)v2+0);
      break;
    default:
      while(len--) *data++ = *v1++ ^ *v2++;
      break;
    }
}
#define xor16(v1,v2,d) __xxor((d),16,(v1),(v2))
#define val_by2on3(x)  ((0xaaab*(x))>>16) //fixed point *2/3

unsigned short cardkeys[3][32];
unsigned char stateD3A[16];

static void cCamCryptVG2_LongMult(unsigned short *pData, unsigned short *pLen, unsigned int mult, unsigned int carry);
static void cCamCryptVG2_PartialMod(unsigned short val, unsigned int count, unsigned short *outkey, const unsigned short *inkey);
static void cCamCryptVG2_RotateRightAndHash(unsigned char *p);
static void cCamCryptVG2_Reorder16A(unsigned char *dest, const unsigned char *src);
static void cCamCryptVG2_ReorderAndEncrypt(unsigned char *p);
static void cCamCryptVG2_Process_D0(const unsigned char *ins, unsigned char *data);
static void cCamCryptVG2_Process_D1(const unsigned char *ins, unsigned char *data, const unsigned char *status);
static void cCamCryptVG2_Decrypt_D3(unsigned char *ins, unsigned char *data, const unsigned char *status);
static void cCamCryptVG2_PostProcess_Decrypt(unsigned char *buff, int len, unsigned char *cw1, unsigned char *cw2);
static void cCamCryptVG2_SetSeed(unsigned char *Key1, unsigned char *Key2);
static void cCamCryptVG2_GetCamKey(unsigned char *buff);

static void cCamCryptVG2_SetSeed(unsigned char *Key1, unsigned char *Key2)
{
  swap_lb (Key1, 64);
  swap_lb (Key2, 64);
  memcpy(cardkeys[1],Key1,sizeof(cardkeys[1]));
  memcpy(cardkeys[2],Key2,sizeof(cardkeys[2]));
  swap_lb (Key1, 64);
  swap_lb (Key2, 64);
}

static void cCamCryptVG2_GetCamKey(unsigned char *buff)
{
  unsigned short *tb2=(unsigned short *)buff, c=1;
  memset(tb2,0,64);
  tb2[0]=1;
  int i;
  for(i=0; i<32; i++) cCamCryptVG2_LongMult(tb2,&c,cardkeys[1][i],0);
  swap_lb (buff, 64);
}

static void cCamCryptVG2_PostProcess_Decrypt(unsigned char *buff, int len, unsigned char *cw1, unsigned char *cw2)
{
  switch(buff[0]) {
    case 0xD0:
      cCamCryptVG2_Process_D0(buff,buff+5);
      break;
    case 0xD1:
      cCamCryptVG2_Process_D1(buff,buff+5,buff+buff[4]+5);
      break;
    case 0xD3:
      cCamCryptVG2_Decrypt_D3(buff,buff+5,buff+buff[4]+5);
      if(buff[1]==0x54) {
        memcpy(cw1,buff+5,8);
	memset(cw2,0,8); //set to 0 so client will know it is not valid if not overwritten with valid cw
        int ind;
        for(ind=13; ind<len+13-8; ind++) {
          if(buff[ind]==0x25) {
            //memcpy(cw2,buff+5+ind+2,8);
            memcpy(cw2,buff+ind+3,8); //tested on viasat 093E, sky uk 0963, sky it 919  //don't care whether cw is 0 or not
            break;
          }
/*          if(buff[ind+1]==0) break;
          ind+=buff[ind+1];*/
        }
      }
      break;
  }
}

static void cCamCryptVG2_Process_D0(const unsigned char *ins, unsigned char *data)
{
  switch(ins[1]) {
    case 0xb4:
      swap_lb (data, 64);
      memcpy(cardkeys[0],data,sizeof(cardkeys[0]));
      break;
    case 0xbc:
      {
      swap_lb (data, 64);
      unsigned short *idata=(unsigned short *)data;
      const unsigned short *key1=(const unsigned short *)cardkeys[1];
      unsigned short key2[32];
      memcpy(key2,cardkeys[2],sizeof(key2));
      int count2;
      for(count2=0; count2<32; count2++) {
        unsigned int rem=0, div=key1[count2];
        int i;
        for(i=31; i>=0; i--) {
          unsigned int x=idata[i] | (rem<<16);
          rem=(x%div)&0xffff;
          }
        unsigned int carry=1, t=val_by2on3(div) | 1;
        while(t) {
          if(t&1) carry=((carry*rem)%div)&0xffff;
          rem=((rem*rem)%div)&0xffff;
          t>>=1;
          }
        cCamCryptVG2_PartialMod(carry,count2,key2,key1);
        }
      unsigned short idatacount=0;
      int i;
      for(i=31; i>=0; i--) cCamCryptVG2_LongMult(idata,&idatacount,key1[i],key2[i]);
      swap_lb (data, 64);
      unsigned char stateD1[16];
      cCamCryptVG2_Reorder16A(stateD1,data);
      cAES_SetKey(stateD1);
      break;
      }
  }
}

static void cCamCryptVG2_Process_D1(const unsigned char *ins, unsigned char *data, const unsigned char *status)
{
  unsigned char iter[16], tmp[16];
  memset(iter,0,sizeof(iter));
  memcpy(iter,ins,5);
  xor16(iter,stateD3A,iter);
  memcpy(stateD3A,iter,sizeof(iter));

  int datalen=status-data;
  int datalen1=datalen;
  if(datalen<0) datalen1+=15;
  int blocklen=datalen1>>4;
  int i;
  int iblock;
  for(i=0,iblock=0; i<blocklen+2; i++,iblock+=16) {
    unsigned char in[16];
    int docalc=1;
    if(blocklen==i && (docalc=datalen&0xf)) {
      memset(in,0,sizeof(in));
      memcpy(in,&data[iblock],datalen-(datalen1&~0xf));
      }
    else if(blocklen+1==i) {
      memset(in,0,sizeof(in));
      memcpy(&in[5],status,2);
      }
    else
      memcpy(in,&data[iblock],sizeof(in));

    if(docalc) {
      xor16(iter,in,tmp);
      cCamCryptVG2_ReorderAndEncrypt(tmp);
      xor16(tmp,stateD3A,iter);
      }
    }
  memcpy(stateD3A,tmp,16);
}

static void cCamCryptVG2_Decrypt_D3(unsigned char *ins, unsigned char *data, const unsigned char *status)
{
  if(ins[4]>16) ins[4]-=16;
  if(ins[1]==0xbe) memset(stateD3A,0,sizeof(stateD3A));

  unsigned char tmp[16];
  memset(tmp,0,sizeof(tmp));
  memcpy(tmp,ins,5);
  xor16(tmp,stateD3A,stateD3A);

  int len1=ins[4];
  int blocklen=len1>>4;
  if(ins[1]!=0xbe) blocklen++;

  unsigned char iter[16], states[16][16];
  memset(iter,0,sizeof(iter));
  int blockindex;
  for(blockindex=0; blockindex<blocklen; blockindex++) {
    iter[0]+=blockindex;
    xor16(iter,stateD3A,iter);
    cCamCryptVG2_ReorderAndEncrypt(iter);
    xor16(iter,&data[blockindex*16],states[blockindex]);
    if(blockindex==(len1>>4)) {
      int c=len1-(blockindex*16);
      if(c<16) memset(&states[blockindex][c],0,16-c);
      }
    xor16(states[blockindex],stateD3A,stateD3A);
    cCamCryptVG2_RotateRightAndHash(stateD3A);
    }
  memset(tmp,0,sizeof(tmp));
  memcpy(tmp+5,status,2);
  xor16(tmp,stateD3A,stateD3A);
  cCamCryptVG2_ReorderAndEncrypt(stateD3A);

  memcpy(stateD3A,status-16,sizeof(stateD3A));
  cCamCryptVG2_ReorderAndEncrypt(stateD3A);

  memcpy(data,states[0],len1);
  if(ins[1]==0xbe) {
    cCamCryptVG2_Reorder16A(tmp,states[0]);
    cAES_SetKey(tmp);
    }
}

static void cCamCryptVG2_ReorderAndEncrypt(unsigned char *p)
{
  unsigned char tmp[16];
  cCamCryptVG2_Reorder16A(tmp,p);
  cAES_Encrypt(tmp,16,tmp);
  cCamCryptVG2_Reorder16A(p,tmp);
}

// reorder AAAABBBBCCCCDDDD to ABCDABCDABCDABCD

static void cCamCryptVG2_Reorder16A(unsigned char *dest, const unsigned char *src)
{
  int i;
  int j;
  int k;
  for(i=0,k=0; i<4; i++)
    for(j=i; j<16; j+=4,k++)
      dest[k]=src[j];
}

static void cCamCryptVG2_LongMult(unsigned short *pData, unsigned short *pLen, unsigned int mult, unsigned int carry)
{
  int i;
  for(i=0; i<*pLen; i++) {
    carry+=pData[i]*mult;
    pData[i]=(unsigned short)carry;
    carry>>=16;
    }
  if(carry) pData[(*pLen)++]=carry;
}

static void cCamCryptVG2_PartialMod(unsigned short val, unsigned int count, unsigned short *outkey, const unsigned short *inkey)
{
  if(count) {
    unsigned int mod=inkey[count];
    unsigned short mult=(inkey[count]-outkey[count-1])&0xffff;
    unsigned int i;
    unsigned int ib1;
    for(i=0,ib1=count-2; i<count-1; i++,ib1--) {
      unsigned int t=(inkey[ib1]*mult)%mod;
      mult=t-outkey[ib1];
      if(mult>t) mult+=mod;
      }
    mult+=val;
    if((val>mult) || (mod<mult)) mult-=mod;
    outkey[count]=(outkey[count]*mult)%mod;
    }
  else
    outkey[0]=val;
}

static const unsigned char table1[256] = {
  0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5, 0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
  0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0, 0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
  0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc, 0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
  0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a, 0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
  0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0, 0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
  0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b, 0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
  0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85, 0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
  0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5, 0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
  0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17, 0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
  0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88, 0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
  0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c, 0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
  0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9, 0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
  0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6, 0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
  0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e, 0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
  0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94, 0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
  0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68, 0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16,
  };

static void cCamCryptVG2_RotateRightAndHash(unsigned char *p)
{
  unsigned char t1=p[15];
  int i;
  for(i=0; i<16; i++) {
    unsigned char t2=t1;
    t1=p[i]; p[i]=table1[(t1>>1)|((t2&1)<<7)];
    }
}

//////  ====================================================================================

unsigned char CW1[8], CW2[8];

extern uchar cta_res[];
extern ushort cta_lr;

extern int io_serial_need_dummy_char;

struct CmdTabEntry {
  unsigned char cla;
  unsigned char cmd;
  unsigned char len;
  unsigned char mode;
};

struct CmdTab {
  unsigned char index;
  unsigned char size;
  unsigned char Nentries;
  unsigned char dummy;
  struct CmdTabEntry e[1];
};

struct CmdTab *cmd_table=NULL;
static void memorize_cmd_table (const unsigned char *mem, int size){
  cmd_table=(struct CmdTab *)malloc(sizeof(unsigned char) * size);
  memcpy(cmd_table,mem,size);
}

static int cmd_table_get_info(const unsigned char *cmd, unsigned char *rlen, unsigned char *rmode)
{
  struct CmdTabEntry *pcte=cmd_table->e;
  int i;
  for(i=0; i<cmd_table->Nentries; i++,pcte++)
    if(cmd[1]==pcte->cmd) {
      *rlen=pcte->len;
      *rmode=pcte->mode;
      return 1;
      }
  return 0;
}

static int status_ok(const unsigned char *status){
    //cs_log("[videoguard2-reader] check status %02x%02x", status[0],status[1]);
    return (status[0] == 0x90 || status[0] == 0x91)
           && (status[1] == 0x00 || status[1] == 0x01
               || status[1] == 0x20 || status[1] == 0x21
               || status[1] == 0x80 || status[1] == 0x81
               || status[1] == 0xa0 || status[1] == 0xa1);
}

#define write_cmd(cmd, data) (card_write(cmd, data) == 0)
#define read_cmd(cmd, data) (card_write(cmd, NULL) == 0)

static int read_cmd_len(const unsigned char *cmd) 
{ 
  unsigned char cmd2[5]; 
  memcpy(cmd2,cmd,5); 
  cmd2[3]=0x80; 
  cmd2[4]=1; 
  if(!read_cmd(cmd2,NULL) || cta_res[1] != 0x90 || cta_res[2] != 0x00) { 
    cs_debug("[videoguard2-reader] failed to read %02x%02x cmd length (%02x %02x)",cmd[1],cmd[2],cta_res[1],cta_res[2]); 
    return -1;
    }
  return cta_res[0];
}

static int do_cmd(const unsigned char *ins, const unsigned char *txbuff, unsigned char *rxbuff)
{
  unsigned char ins2[5];
  memcpy(ins2,ins,5);
  unsigned char len=0, mode=0;
  if(cmd_table_get_info(ins2,&len,&mode)) {
    if(len==0xFF && mode==2) {
      if(ins2[4]==0) ins2[4]=len=read_cmd_len(ins2);
      }
    else if(mode!=0) ins2[4]=len;
    }
  if(ins2[0]==0xd3) ins2[4]=len+16;
  len=ins2[4];

  unsigned char tmp[264];
  if(!rxbuff) rxbuff=tmp;
  if(mode>1) {
    if(!read_cmd(ins2,NULL) || !status_ok(cta_res+len)) return -1;
    memcpy(rxbuff,ins2,5);
    memcpy(rxbuff+5,cta_res,len);
    memcpy(rxbuff+5+len,cta_res+len,2);
    }
  else {
    if(!write_cmd(ins2,(uchar *)txbuff) || !status_ok(cta_res)) return -2;
    memcpy(rxbuff,ins2,5);
    memcpy(rxbuff+5,txbuff,len);
    memcpy(rxbuff+5+len,cta_res,2);
    }

  cCamCryptVG2_PostProcess_Decrypt(rxbuff,len,CW1,CW2);

  // Log decrypted INS54
  ///if (rxbuff[1] == 0x54) {
  ///  cs_dump (rxbuff, 5, "Decrypted INS54:");
  ///  cs_dump (rxbuff + 5, rxbuff[4], "");
  ///}

  return len;
}

static void rev_date_calc(const unsigned char *Date, int *year, int *mon, int *day, int *hh, int *mm, int *ss)
{
  *year=(Date[0]/12)+BASEYEAR;
  *mon=(Date[0]%12)+1;
  *day=Date[1];
  *hh=Date[2]/8;
  *mm=(0x100*(Date[2]-*hh*8)+Date[3])/32;
  *ss=(Date[3]-*mm*32)*2;
}

typedef struct{
   unsigned short id;
   char name[32];
} tier_t;

static tier_t skyit_tiers[] =
{
  { 0x0320, "Promo" },
  { 0x000B, "Service" },
  { 0x0219, "Mondo HD" },
  { 0x021A, "Cinema HD" },
  { 0x021B, "Cinema" },
  { 0x0222, "Sport HD" },
  { 0x0224, "Sky Play IT" },
  { 0x0226, "Mondo" },
  { 0x0228, "Sport" },
  { 0x0229, "Disney Channel" },
  { 0x022A, "Inter Channel" },
  { 0x022B, "Milan Channel" },
  { 0x022C, "Roma Channel" },
  { 0x022D, "Classica" },
  { 0x022E, "Music & News" },
  { 0x022F, "Caccia e Pesca" },
  { 0x023D, "Juventus Channel" },
  { 0x023E, "Moto TV" },
  { 0x026B, "Calcio HD" },
  { 0x0275, "Promo" },
  { 0x0295, "Calcio" },
  { 0x0296, "Serie B" },
  { 0x02FE, "PPV" }
};

static char *get_tier_name(unsigned short tier_id){
  static char *empty = "";
  unsigned int i;

  switch (reader[ridx].caid[0])
  {
    case 0x919:
    case 0x93b:
    for (i = 0; i < sizeof(skyit_tiers) / sizeof(tier_t); ++i)
      if (skyit_tiers[i].id == tier_id)
         return skyit_tiers[i].name;
    break;
  }
  return empty;
}

static void read_tiers(void)
{
  static const unsigned char ins2a[5] = { 0xd0,0x2a,0x00,0x00,0x00 };
  int l;
  l=do_cmd(ins2a,NULL,NULL);
  if(l<0 || !status_ok(cta_res+l)) return;
  static unsigned char ins76[5] = { 0xd0,0x76,0x00,0x00,0x00 };
  ins76[3]=0x7f; ins76[4]=2;
  if(!read_cmd(ins76,NULL) || !status_ok(cta_res+2)) return;
  ins76[3]=0; ins76[4]=0;
  int num=cta_res[1];
  int i;
  reader[ridx].init_history_pos = 0; //reset for re-read
  memset(reader[ridx].init_history, 0, sizeof(reader[ridx].init_history));
  for(i=0; i<num; i++) {
    ins76[2]=i;
    l=do_cmd(ins76,NULL,NULL);
    if(l<0 || !status_ok(cta_res+l)) return;
    if(cta_res[2]==0 && cta_res[3]==0) break;
    int y,m,d,H,M,S;
    rev_date_calc(&cta_res[4],&y,&m,&d,&H,&M,&S);
    unsigned short tier_id = (cta_res[2] << 8) | cta_res[3];
    char *tier_name = get_tier_name(tier_id);
    cs_ri_log("[videoguard2-reader] tier: %04x, expiry date: %04d/%02d/%02d-%02d:%02d:%02d %s",tier_id,y,m,d,H,M,S,tier_name);
    }
}

int videoguard_card_init(ATR newatr)
{
	get_hist;
	if ((hist_size < 7) || (hist[1] != 0xB0) || (hist[4] != 0xFF) || (hist[5] != 0x4A) || (hist[6] != 0x50))
		return ERROR;
	get_atr;
  /* known atrs */
  unsigned char atr_bskyb[] = { 0x3F, 0x7F, 0x13, 0x25, 0x03, 0x33, 0xB0, 0x06, 0x69, 0xFF, 0x4A, 0x50, 0xD0, 0x00, 0x00, 0x53, 0x59, 0x00, 0x00, 0x00 };
  unsigned char atr_bskyb_new[] = { 0x3F, 0xFD, 0x13, 0x25, 0x02, 0x50, 0x00, 0x0F, 0x33, 0xB0, 0x0F, 0x69, 0xFF, 0x4A, 0x50, 0xD0, 0x00, 0x00, 0x53, 0x59, 0x02 };
  unsigned char atr_skyitalia[] = { 0x3F, 0xFF, 0x13, 0x25, 0x03, 0x10, 0x80, 0x33, 0xB0, 0x0E, 0x69, 0xFF, 0x4A, 0x50, 0x70, 0x00, 0x00, 0x49, 0x54, 0x02, 0x00, 0x00 };
  unsigned char atr_skyitalia93b[] = { 0x3F, 0xFD, 0x13, 0x25, 0x02, 0x50, 0x80, 0x0F, 0x33, 0xB0, 0x13, 0x69, 0xFF, 0x4A, 0x50, 0xD0, 0x80, 0x00, 0x49, 0x54, 0x03 };
  unsigned char atr_directv[] = { 0x3F, 0x78, 0x13, 0x25, 0x03, 0x40, 0xB0, 0x20, 0xFF, 0xFF, 0x4A, 0x50, 0x00 };
  unsigned char atr_yes[] = { 0x3F, 0xFF, 0x13, 0x25, 0x03, 0x10, 0x80, 0x33, 0xB0, 0x11, 0x69, 0xFF, 0x4A, 0x50, 0x50, 0x00, 0x00, 0x47, 0x54, 0x01, 0x00, 0x00 };
  unsigned char atr_viasat_new[] = { 0x3F, 0x7D, 0x11, 0x25, 0x02, 0x41, 0xB0, 0x03, 0x69, 0xFF, 0x4A, 0x50, 0xF0, 0x80, 0x00, 0x56, 0x54, 0x03};
  unsigned char atr_viasat_scandinavia[] = { 0x3F, 0x7F, 0x11, 0x25, 0x03, 0x33, 0xB0, 0x09, 0x69, 0xFF, 0x4A, 0x50, 0x70, 0x00, 0x00, 0x56, 0x54, 0x01, 0x00, 0x00 };
  unsigned char atr_premiere[] = { 0x3F, 0xFF, 0x11, 0x25, 0x03, 0x10, 0x80, 0x41, 0xB0, 0x07, 0x69, 0xFF, 0x4A, 0x50, 0x70, 0x00, 0x00, 0x50, 0x31, 0x01, 0x00, 0x11 };
  unsigned char atr_kbw[] = { 0x3F, 0xFF, 0x14, 0x25, 0x03, 0x10, 0x80, 0x54, 0xB0, 0x01, 0x69, 0xFF, 0x4A, 0x50, 0x70, 0x00, 0x00, 0x4B, 0x57, 0x01, 0x00, 0x00};
  unsigned char atr_get[] = { 0x3F, 0xFF, 0x14, 0x25, 0x03, 0x10, 0x80, 0x33, 0xB0, 0x10, 0x69, 0xFF, 0x4A, 0x50, 0x70, 0x00, 0x00, 0x5A, 0x45, 0x01, 0x00, 0x00};
  unsigned char atr_foxtel_90b[] = { 0x3F, 0x7F, 0x11, 0x25, 0x03, 0x33, 0xB0, 0x09, 0x69, 0xFF, 0x4A, 0x50, 0x70, 0x00, 0x00, 0x46, 0x44, 0x01, 0x00, 0x00};

    if ((atr_size == sizeof (atr_bskyb)) && (memcmp (atr, atr_bskyb, atr_size) == 0))
    {
        cs_ri_log("[videoguard2-reader] type: VideoGuard BSkyB");
        /* BSkyB seems to need one additionnal byte in the serial communication... */
        io_serial_need_dummy_char = 1;
				BASEYEAR = 2000;
    }
    else if ((atr_size == sizeof (atr_bskyb_new)) && (memcmp (atr, atr_bskyb_new, atr_size) == 0))
    {
        cs_ri_log("[videoguard2-reader] type: VideoGuard BSkyB - New");
    }
    else if ((atr_size == sizeof (atr_skyitalia)) && (memcmp (atr, atr_skyitalia, atr_size) == 0))
    {
        cs_ri_log("[videoguard2-reader] type: VideoGuard Sky Italia");
    }
    else if ((atr_size == sizeof (atr_directv)) && (memcmp (atr, atr_directv, atr_size) == 0))
    {
        cs_ri_log("[videoguard2-reader] type: VideoGuard DirecTV");
    }
    else if ((atr_size == sizeof (atr_yes)) && (memcmp (atr, atr_yes, atr_size) == 0))
    {
        cs_ri_log("[videoguard2-reader] type: VideoGuard YES DBS Israel");
    }
    else if ((atr_size == sizeof (atr_viasat_new)) && (memcmp (atr, atr_viasat_new, atr_size) == 0))
    {
        cs_ri_log("[videoguard2-reader] type: VideoGuard Viasat new (093E)");
				BASEYEAR = 2000;
    }
    else if ((atr_size == sizeof (atr_viasat_scandinavia)) && (memcmp (atr, atr_viasat_scandinavia, atr_size) == 0))
    {
        cs_ri_log("[videoguard2-reader] type: VideoGuard Viasat Scandinavia");
				BASEYEAR = 2000;
    }
    else if ((atr_size == sizeof (atr_skyitalia93b)) && (memcmp (atr, atr_skyitalia93b, atr_size) == 0))
    {
        cs_ri_log("[videoguard2-reader] type: VideoGuard Sky Italia new (093B)");
    }
    else if ((atr_size == sizeof (atr_premiere)) && (memcmp (atr, atr_premiere, atr_size) == 0))
    {
        cs_ri_log("[videoguard2-reader] type: VideoGuard Sky Germany");
    }
    else if ((atr_size == sizeof (atr_kbw)) && (memcmp (atr, atr_kbw, atr_size) == 0))
    {
        cs_ri_log("[videoguard2-reader] type: VideoGuard Kabel BW");
    }
    else if ((atr_size == sizeof (atr_get)) && (memcmp (atr, atr_get, atr_size) == 0))
    {
        cs_ri_log("[videoguard2-reader] type: VideoGuard Get Kabel Norway");
        			BASEYEAR = 2004;
    }
    else if ((atr_size == sizeof (atr_foxtel_90b)) && (memcmp (atr, atr_foxtel_90b, atr_size) == 0))
    {    
	cs_ri_log("[videoguard2-reader] type: VideoGuard Foxtel Australia (090b)");
				BASEYEAR = 2000;			
    }
/*    else
    {
        // not a known videoguard
        return (0);
    }*/
    //a non videoguard2/NDS card will fail on read_cmd_len(ins7401)
    //this way also unknown videoguard2/NDS cards will work

  unsigned char ins7401[5] = { 0xD0,0x74,0x01,0x00,0x00 };
  int l;
  if((l=read_cmd_len(ins7401))<0) return ERROR; //not a videoguard2/NDS card or communication error
  ins7401[4]=l;
  if(!read_cmd(ins7401,NULL) || !status_ok(cta_res+l)) {
    cs_log ("[videoguard2-reader] failed to read cmd list");
    return ERROR;
    }
  memorize_cmd_table (cta_res,l);

  unsigned char buff[256];

  unsigned char ins7416[5] = { 0xD0,0x74,0x16,0x00,0x00 };
  if(do_cmd(ins7416, NULL, NULL)<0) {
    cs_log ("[videoguard2-reader] cmd 7416 failed");
    return ERROR;
    }

  unsigned char ins36[5] = { 0xD0,0x36,0x00,0x00,0x00 };
  unsigned char boxID [4];

  if (reader[ridx].boxid > 0) {
    /* the boxid is specified in the config */
    int i;
    for (i=0; i < 4; i++) {
        boxID[i] = (reader[ridx].boxid >> (8 * (3 - i))) % 0x100;
    }
  } else {
    /* we can try to get the boxid from the card */
    int boxidOK=0;
    l=do_cmd(ins36, NULL, buff);
    if(l>=0) {
      int i;
      for(i=0; i<l ;i++) {
        if(buff[i+1]==0xF3 && (buff[i]==0x00 || buff[i]==0x0A)) {
          memcpy(&boxID,&buff[i+2],sizeof(boxID));
          boxidOK=1;
          break;
          }
        }
      }

    if(!boxidOK) {
      cs_log ("[videoguard2-reader] no boxID available");
      return ERROR;
      }
  }

  unsigned char ins4C[5] = { 0xD0,0x4C,0x00,0x00,0x09 };
  unsigned char payload4C[9] = { 0,0,0,0, 3,0,0,0,4 };
  memcpy(payload4C,boxID,4);
  if(!write_cmd(ins4C,payload4C) || !status_ok(cta_res+l)) {
    cs_log("[videoguard2-reader] sending boxid failed");
    return ERROR;
    }

  //short int SWIRDstatus = cta_res[1];
  unsigned char ins58[5] = { 0xD0,0x58,0x00,0x00,0x00 };
  l=do_cmd(ins58, NULL, buff);
  if(l<0) {
    cs_log("[videoguard2-reader] cmd ins58 failed");
    return ERROR;
    }
  memset(reader[ridx].hexserial, 0, 8);
  memcpy(reader[ridx].hexserial+2, cta_res+3, 4);
  reader[ridx].caid[0] = cta_res[24]*0x100+cta_res[25];

  /* we have one provider, 0x0000 */
  reader[ridx].nprov = 1;
  memset(reader[ridx].prid, 0x00, sizeof(reader[ridx].prid));

  /*
  cs_log ("[videoguard2-reader] INS58 : Fuse byte=0x%02X, IRDStatus=0x%02X", cta_res[2],SWIRDstatus);
  if (SWIRDstatus==4)  {
  // If swMarriage=4, not married then exchange for BC Key
  cs_log ("[videoguard2-reader] Card not married, exchange for BC Keys");
   */

  unsigned char seed1[] = {
    0xb9, 0xd5, 0xef, 0xd5, 0xf5, 0xd5, 0xfb, 0xd5, 0x31, 0xd6, 0x43, 0xd6, 0x55, 0xd6, 0x61, 0xd6,
    0x85, 0xd6, 0x9d, 0xd6, 0xaf, 0xd6, 0xc7, 0xd6, 0xd9, 0xd6, 0x09, 0xd7, 0x15, 0xd7, 0x21, 0xd7,
    0x27, 0xd7, 0x3f, 0xd7, 0x45, 0xd7, 0xb1, 0xd7, 0xbd, 0xd7, 0xdb, 0xd7, 0x11, 0xd8, 0x23, 0xd8,
    0x29, 0xd8, 0x2f, 0xd8, 0x4d, 0xd8, 0x8f, 0xd8, 0xa1, 0xd8, 0xad, 0xd8, 0xbf, 0xd8, 0xd7, 0xd8
    };
  unsigned char seed2[] = {
    0x01, 0x00, 0xcf, 0x13, 0xe0, 0x60, 0x54, 0xac, 0xab, 0x99, 0xe6, 0x0c, 0x9f, 0x5b, 0x91, 0xb9,
    0x72, 0x72, 0x4d, 0x5b, 0x5f, 0xd3, 0xb7, 0x5b, 0x01, 0x4d, 0xef, 0x9e, 0x6b, 0x8a, 0xb9, 0xd1,
    0xc9, 0x9f, 0xa1, 0x2a, 0x8d, 0x86, 0xb6, 0xd6, 0x39, 0xb4, 0x64, 0x65, 0x13, 0x77, 0xa1, 0x0a,
    0x0c, 0xcf, 0xb4, 0x2b, 0x3a, 0x2f, 0xd2, 0x09, 0x92, 0x15, 0x40, 0x47, 0x66, 0x5c, 0xda, 0xc9
    };
  cCamCryptVG2_SetSeed(seed1,seed2);

  unsigned char insB4[5] = { 0xD0,0xB4,0x00,0x00,0x40 };
  unsigned char tbuff[64];
  cCamCryptVG2_GetCamKey(tbuff);
  l=do_cmd(insB4, tbuff, NULL);
  if(l<0 || !status_ok(cta_res)) {
    cs_log ("[videoguard2-reader] cmd D0B4 failed (%02X%02X)", cta_res[0], cta_res[1]);
    return ERROR;
    }

  unsigned char insBC[5] = { 0xD0,0xBC,0x00,0x00,0x00 };
  l=do_cmd(insBC, NULL, NULL);
  if(l<0) {
    cs_log("[videoguard2-reader] cmd D0BC failed");
    return ERROR;
    }

  unsigned char insBE[5] = { 0xD3,0xBE,0x00,0x00,0x00 };
  l=do_cmd(insBE, NULL, NULL);
  if(l<0) {
    cs_log("[videoguard2-reader] cmd D3BE failed");
    return ERROR;
    }

  unsigned char ins58a[5] = { 0xD1,0x58,0x00,0x00,0x00 };
  l=do_cmd(ins58a, NULL, NULL);
  if(l<0) {
    cs_log("[videoguard2-reader] cmd D158 failed");
    return ERROR;
    }

  unsigned char ins4Ca[5] = { 0xD1,0x4C,0x00,0x00,0x00 };
  l=do_cmd(ins4Ca,payload4C, NULL);
  if(l<0 || !status_ok(cta_res)) {
    cs_log("[videoguard2-reader] cmd D14Ca failed");
    return ERROR;
    }

  cs_ri_log("[videoguard2-reader] type: VideoGuard, caid: %04X, serial: %02X%02X%02X%02X, BoxID: %02X%02X%02X%02X",
         reader[ridx].caid[0],
         reader[ridx].hexserial[2],reader[ridx].hexserial[3],reader[ridx].hexserial[4],reader[ridx].hexserial[5],
         boxID[0],boxID[1],boxID[2],boxID[3]);

  ///read_tiers();

  cs_log("[videoguard2-reader] ready for requests");

  return OK;
}

int videoguard_do_ecm(ECM_REQUEST *er)
{
  static unsigned char ins40[5] = { 0xD1,0x40,0x00,0x80,0xFF };
  static const unsigned char ins54[5] = { 0xD3,0x54,0x00,0x00,0x00};
  int posECMpart2=er->ecm[6]+7;
  int lenECMpart2=er->ecm[posECMpart2]+1;
  unsigned char tbuff[264];
  tbuff[0]=0;
  memcpy(&tbuff[1],&(er->ecm[posECMpart2+1]),lenECMpart2-1);
  ins40[4]=lenECMpart2;
  int l;
  l = do_cmd(ins40,tbuff,NULL);
  if(l>0 && status_ok(cta_res)) {
    l = do_cmd(ins54,NULL,NULL);
    if(l>0 && status_ok(cta_res+l)) {
      if (!cw_is_valid(CW1)) //sky cards report 90 00 = ok but send cw = 00 when channel not subscribed
	return ERROR;
      if(er->ecm[0]&1) {
        memcpy(er->cw+8,CW1,8);
        memcpy(er->cw+0,CW2,8);
      }
      else {
        memcpy(er->cw+0,CW1,8);
        memcpy(er->cw+8,CW2,8);
      }

      //test for postprocessing marker
      int posB0 = -1;
      int i;
      for (i = 6; i < posECMpart2; i++)
      {
        if (er->ecm[i] == 0xB0 && er->ecm[i+1] == 0x01 ) {
			posB0 = i;
      	  break;
		}
      }
      if (posB0 != -1) {
	postprocess_cw(er->cw+0, er->ecm[posB0+2]);
	postprocess_cw(er->cw+8, er->ecm[posB0+2]);
      }
      return OK;
    }
  }
  return ERROR;
}

static int num_addr(const unsigned char *data)
{
  return ((data[3]&0x30)>>4)+1;
}

static int addr_mode(const unsigned char *data)
{
  switch(data[3]&0xC0) {
    case 0x40: return 3;
    case 0x80: return 2;
    default:   return 0;
    }
}

static const unsigned char * payload_addr(const unsigned char *data, const unsigned char *a)
{
  int s;
  int l;
  const unsigned char *ptr = NULL;

  switch(addr_mode(data)) {
    case 2: s=3; break;
    case 3: case 0: s=4; break;
    default: return NULL;
    }

  int position=-1;
  for(l=0;l<num_addr(data);l++) {
    if(!memcmp(&data[l*4+4],a+2,s)) {
      position=l;
      break;
      }
    }

  /* skip EMM-G but not EMM from cccam */
  if (position == -1 && data[1] != 0x00) return NULL;

  int num_ua = (position == -1) ? 0 : num_addr(data);

  /* skip header and the list of addresses */
  ptr = data+4+4*num_ua;

  if (*ptr != 0x02)          // some clients omit 00 00 separator */
  {
    ptr += 2;                // skip 00 00 separator
    if (*ptr == 0x00) ptr++; // skip optional 00
    ptr++;                   // skip the 1st bitmap len
  }

  /* check */
  if (*ptr != 0x02) return NULL;

  /* skip the 1st timestamp 02 00 or 02 06 xx aabbccdd yy */
  ptr += 2 + ptr[1];

  for(l=0;l<position;l++) {

    /* skip the payload of the previous SA */
    ptr += 1 + ptr [0];

    /* skip optional 00 */
    if (*ptr == 0x00) ptr++;

    /* skip the bitmap len */
    ptr++;

    /* check */
    if (*ptr != 0x02) return NULL;

    /* skip the timestamp 02 00 or 02 06 xx aabbccdd yy */
    ptr += 2 + ptr[1];
    }

  return ptr;
}

int videoguard_do_emm(EMM_PACKET *ep)
{
  unsigned char ins42[5] = { 0xD1,0x42,0x00,0x00,0xFF };
  int rc=ERROR;

  const unsigned char *payload = payload_addr(ep->emm, reader[ridx].hexserial);
  while (payload) {
    ins42[4]=*payload;
    int l = do_cmd(ins42,payload+1,NULL);
    if(l>0 && status_ok(cta_res)) {
      rc=OK;
      }

    cs_log("[videoguard2-reader] EMM request return code : %02X%02X", cta_res[0], cta_res[1]);
//cs_dump(ep->emm, 64, "EMM:");
    if (status_ok (cta_res) && (cta_res[1] & 0x01)) {
      read_tiers();
      }

    if (num_addr(ep->emm) == 1 && (int)(&payload[1] - &ep->emm[0]) + *payload + 1 < ep->l) {
      payload += *payload + 1;
      if (*payload == 0x00) ++payload;
      ++payload;
      if (*payload != 0x02) break;
      payload += 2 + payload[1];
      }
    else
      payload = 0;

    }

  return(rc);
}

int videoguard_card_info(void)
{
  /* info is displayed in init, or when processing info */
  cs_log("[videoguard2-reader] card detected");
  cs_log("[videoguard2-reader] type: VideoGuard" );
  read_tiers ();
  return OK;
}
